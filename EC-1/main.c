#ifndef MAIN_C
#define MAIN_C

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include "defs.h"

unsigned char* lfg(unsigned char*, unsigned int, unsigned int, unsigned int);
unsigned char* to_permutation(unsigned char*, unsigned int);
int p_gen();
int s_gen();
unsigned char* permutate(unsigned char*, unsigned char*);
int sub(unsigned char*, unsigned char*);

int main(int argc, char **argv)
{
    
    return 0;
}

/*
 * Apply the S-Box to the data in-place.
 */
int sub(unsigned char **data, unsigned char *s)
{
    if (S == NULL)
        return FAIL;
    
    /* Substitute the data in-place */
    for (int i = 0; i < BLOCKSIZE; i++) {
        /* Get the coordinates for the S-Box */
        unsigned int l = get_xy((*data)[i] >> 4),
                     r = get_xy((*data)[i] & 0xF);
        /* Get the substituted value and place it back into data */
        unsigned char l_subbed = s[(l >> sizeof(unsigned short)) * S_WIDTH + (l & 0xF)],
                      r_subbed = s[(r >> sizeof(unsigned short)) * S_WIDTH + (r & 0xF)];
        (*data)[i] = (l_subbed << 4) | (r_subbed & 0xF);
    }
}

/*
 * Get the X and Y coordinates for the S-Box, pack them into an unsigned int
 */
unsigned int get_xy(unsigned char data)
{
    unsigned short x = (data >> 1) & 0x3,
                   y = ((data & 0x8) >> 2) | (data & 0x1);
    return (x << sizeof(unsigned short)) | y;
}

/*
 * Permutate the data according to the P-Box, returning a pointer to the
 * permutated version of the data.
 */
unsigned char* permutate(unsigned char *data, unsigned char *p)
{
    if (p == NULL || data == NULL)
        return NULL;
    
    unsigned char *output = (unsigned char*) malloc(BLOCKSIZE * sizeof(char));
    for (int i = 0; i < BLOCKSIZE; i++)
        output[i] = data[p[i]];
    return output;
}

/*
 * Generate the S-Boxes
 */
int s_gen()
{
    /* If the P-Boxes haven't been generated, exit with an error */
    if (P == NULL)
        return FAIL;
    
    /* Allocate the S-Boxes */
    S = (unsigned char**) malloc(ROUNDS * sizeof(unsigned char*));
    for (int i = 0; i < ROUNDS; i++) {
        S[i] = malloc(BLOCKSIZE * sizeof(unsigned char));
        for (int j = 0; j < BLOCKSIZE; j++) {
            S[i][j] = P[i][j];
        }
    }

    return SUCCESS;
}

/*
 * Generate the P-Boxes
 */
int p_gen()
{
    unsigned char *stream,
                  *tmp,
                  tmp2;
    /* Define the base P-Box */
    unsigned char p[BLOCKSIZE] = {14, 0, 1, 12, 2, 8, 3, 6, 7, 4, 15, 13, 11, 5, 10, 9};
    
    /* Define the 2D array to hold all the P-Boxes and malloc them */
    P = (unsigned char**) malloc(ROUNDS * sizeof(unsigned char*));
    for (int i = 0; i < ROUNDS; i++)
        P[i] = (unsigned char*) malloc(BLOCKSIZE * sizeof(unsigned char));

    /* Define a temporary array for holding streams */
    stream = (unsigned char*) malloc(BLOCKSIZE * sizeof(unsigned char));
    
    /* Copy over the base P-Box into P0 */
    memcpy(P[0], p, BLOCKSIZE * sizeof(unsigned char));

    /* Fill the remaining P-Boxes */
    for (int i = 1; i < ROUNDS; i++) {
        /* The first 10 bytes are generated by an LFG */
        tmp = lfg(P[i - 1], 10, 7, 10);
        memcpy(stream, tmp, 10);    
        free(tmp);

        /*
         * Get the 8 least significant bytes from the P[i - 1] and rotate them
         * 2 bits to the right.
         */
        unsigned long bytes = (unsigned long) &(P[i - 1][BLOCKSIZE]);
        bytes &= (0xFFFFFFFFFFFF);
        bytes = (bytes >> 2) | (bytes << 46);

        /* Copy the bits into the array */
        tmp = (unsigned char*) &bytes;
        memcpy(stream + 10, tmp, 6);

        /* 
         * Generate a permutation from the pseudorandom stream, copy it, and
         * free tmp.
         */
        tmp = to_permutation(stream, BLOCKSIZE);
        memcpy(P[i], tmp, BLOCKSIZE);
        free(tmp);
    }

    /* Print out the P-Boxes */
    /*
    for (int i = 0; i < ROUNDS; i++) {
        printf("{");
        for (int j = 0; j < BLOCKSIZE - 1; j++)
            printf("%d, ", P[i][j]);
        printf("%d},\n", P[i][BLOCKSIZE - 1]);
    }
    */
    

    /* Free malloc'd memory */
    free(stream);

    return SUCCESS;
}


/*
 * Apply a Lagged Fibonacci Generator to a 10-byte seed, using j = 7 and k = 10
 * A length of 0 returns the seed
 */
unsigned char* lfg(unsigned char *seed, unsigned int length, unsigned int J, unsigned int K)
{
    if (length < 1)
        return seed;
    
    unsigned char *output = (unsigned char*) malloc(length * sizeof(char));
    unsigned char left, right;

    /* Apply the LFG to the seed */
    right = seed[K - 1];
    for (int i = 0; i < length; i++) {
        /* 
         * Define the left register to be the last four chars, then use the
         * output stream. After the output is calculated, adjust the right
         * register.
         */
        left = (i <= (K - J)) ? seed[J - 1 + i] : output[i - (K - J) - 1];
        output[i] = (left + right) % 256;
        right = output[i];
    }

    return output;
}

/*
 * Convert a pseudorandom stream to a permutation
 */
unsigned char* to_permutation(unsigned char *stream, unsigned int length)
{
    unsigned char *output = (unsigned char*) malloc(length * sizeof(char));
    int *tmp = (int*) malloc(length * sizeof(int));

    /* Set the output array to -1 */
    memset(tmp, -1, sizeof(int) * length);

    /* Create a permutation from the pseudorandom sequence */
    for (int i = 0, j = length; i < length && j > 0; i++, j--) {
        /* Calculate the position the number should be */
        int pos = stream[i] % j;
        int k;
        /* Find the pos'th empty element */
        for (k = 0; k < length && pos >= 0; k++)
            if (tmp[k] == -1)
                pos--;
        output[k - 1] = i;
        tmp[k - 1] = i;
    }
    free(tmp);

    return output;
}

#endif